"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const fs = require("fs-extra");
const path = require("path");
const os = require("os");
const cross_spawn_promise_1 = require("@malept/cross-spawn-promise");
const checksum_1 = require("./helpers/checksum");
const rebuild_1 = require("./helpers/rebuild");
const electron_version_1 = require("./helpers/electron-version");
const rebuild_2 = require("../src/rebuild");
const testElectronVersion = electron_version_1.getExactElectronVersionSync();
describe('rebuilder', () => {
    const testModulePath = path.resolve(os.tmpdir(), 'electron-rebuild-test');
    const timeoutSeconds = process.platform === 'win32' ? 5 : 2;
    const msvs_version = process.env.GYP_MSVS_VERSION;
    const resetMSVSVersion = () => {
        if (msvs_version) {
            process.env.GYP_MSVS_VERSION = msvs_version;
        }
    };
    const resetTestModule = async () => {
        await fs.remove(testModulePath);
        await fs.mkdirs(testModulePath);
        await fs.copy(path.resolve(__dirname, '../test/fixture/native-app1/package.json'), path.resolve(testModulePath, 'package.json'));
        await cross_spawn_promise_1.spawn('npm', ['install'], { cwd: testModulePath });
        resetMSVSVersion();
    };
    const cleanupTestModule = async () => {
        await fs.remove(testModulePath);
        resetMSVSVersion();
    };
    const optionSets = [
        { args: [testModulePath, testElectronVersion, process.arch], name: 'sequential args' },
        { args: {
                buildPath: testModulePath,
                electronVersion: testElectronVersion,
                arch: process.arch
            }, name: 'options object' }
    ];
    for (const options of optionSets) {
        describe(`core behavior -- ${options.name}`, function () {
            this.timeout(timeoutSeconds * 60 * 1000);
            before(async () => {
                await resetTestModule();
                let args = options.args;
                if (!Array.isArray(args) && typeof args === 'string') {
                    args = [args];
                }
                process.env.ELECTRON_REBUILD_TESTS = 'true';
                if (Array.isArray(args)) {
                    // eslint-disable-next-line @typescript-eslint/ban-types
                    await rebuild_2.rebuild(...args);
                }
                else {
                    await rebuild_2.rebuild(args);
                }
            });
            it('should have rebuilt top level prod dependencies', async () => {
                await rebuild_1.expectNativeModuleToBeRebuilt(testModulePath, 'ref-napi');
            });
            it('should have rebuilt top level prod dependencies that are using prebuild', async () => {
                await rebuild_1.expectNativeModuleToBeRebuilt(testModulePath, 'farmhash');
            });
            it('should have rebuilt children of top level prod dependencies', async () => {
                await rebuild_1.expectNativeModuleToBeRebuilt(testModulePath, 'leveldown');
            });
            it('should have rebuilt children of scoped top level prod dependencies', async () => {
                await rebuild_1.expectNativeModuleToBeRebuilt(testModulePath, '@newrelic/native-metrics');
            });
            it('should have rebuilt top level optional dependencies', async () => {
                await rebuild_1.expectNativeModuleToBeRebuilt(testModulePath, 'bcrypt');
            });
            it('should not have rebuilt top level devDependencies', async () => {
                await rebuild_1.expectNativeModuleToNotBeRebuilt(testModulePath, 'ffi-napi');
            });
            after(async () => {
                delete process.env.ELECTRON_REBUILD_TESTS;
                await cleanupTestModule();
            });
        });
    }
    describe('force rebuild', function () {
        this.timeout(timeoutSeconds * 60 * 1000);
        before(resetTestModule);
        after(cleanupTestModule);
        afterEach(resetMSVSVersion);
        it('should skip the rebuild step when disabled', async () => {
            await rebuild_2.rebuild(testModulePath, testElectronVersion, process.arch);
            resetMSVSVersion();
            const rebuilder = rebuild_2.rebuild(testModulePath, testElectronVersion, process.arch, [], false);
            let skipped = 0;
            rebuilder.lifecycle.on('module-skip', () => {
                skipped++;
            });
            await rebuilder;
            chai_1.expect(skipped).to.equal(5);
        });
        it('should rebuild all modules again when disabled but the electron ABI bumped', async () => {
            await rebuild_2.rebuild(testModulePath, testElectronVersion, process.arch);
            resetMSVSVersion();
            const rebuilder = rebuild_2.rebuild(testModulePath, '3.0.0', process.arch, [], false);
            let skipped = 0;
            rebuilder.lifecycle.on('module-skip', () => {
                skipped++;
            });
            await rebuilder;
            chai_1.expect(skipped).to.equal(0);
        });
        it('should rebuild all modules again when enabled', async () => {
            await rebuild_2.rebuild(testModulePath, testElectronVersion, process.arch);
            resetMSVSVersion();
            const rebuilder = rebuild_2.rebuild(testModulePath, testElectronVersion, process.arch, [], true);
            let skipped = 0;
            rebuilder.lifecycle.on('module-skip', () => {
                skipped++;
            });
            await rebuilder;
            chai_1.expect(skipped).to.equal(0);
        });
    });
    describe('only rebuild', function () {
        this.timeout(2 * 60 * 1000);
        beforeEach(resetTestModule);
        afterEach(cleanupTestModule);
        it('should rebuild only specified modules', async () => {
            const nativeModuleBinary = path.join(testModulePath, 'node_modules', 'farmhash', 'build', 'Release', 'farmhash.node');
            const nodeModuleChecksum = await checksum_1.determineChecksum(nativeModuleBinary);
            const rebuilder = rebuild_2.rebuild({
                buildPath: testModulePath,
                electronVersion: testElectronVersion,
                arch: process.arch,
                onlyModules: ['farmhash'],
                force: true
            });
            let built = 0;
            rebuilder.lifecycle.on('module-done', () => built++);
            await rebuilder;
            chai_1.expect(built).to.equal(1);
            const electronModuleChecksum = await checksum_1.determineChecksum(nativeModuleBinary);
            chai_1.expect(electronModuleChecksum).to.not.equal(nodeModuleChecksum);
        });
        it('should rebuild multiple specified modules via --only option', async () => {
            const rebuilder = rebuild_2.rebuild({
                buildPath: testModulePath,
                electronVersion: testElectronVersion,
                arch: process.arch,
                onlyModules: ['ffi-napi', 'ref-napi'],
                force: true
            });
            let built = 0;
            rebuilder.lifecycle.on('module-done', () => built++);
            await rebuilder;
            chai_1.expect(built).to.equal(2);
        });
    });
    describe('debug rebuild', function () {
        this.timeout(10 * 60 * 1000);
        before(resetTestModule);
        after(cleanupTestModule);
        it('should have rebuilt ffi-napi module in Debug mode', async () => {
            await rebuild_2.rebuild({
                buildPath: testModulePath,
                electronVersion: testElectronVersion,
                arch: process.arch,
                onlyModules: ['ffi-napi'],
                force: true,
                debug: true
            });
            await rebuild_1.expectNativeModuleToBeRebuilt(testModulePath, 'ffi-napi', { buildType: 'Debug' });
            await rebuild_1.expectNativeModuleToNotBeRebuilt(testModulePath, 'ffi-napi');
        });
    });
    describe('useElectronClang rebuild', function () {
        this.timeout(10 * 60 * 1000);
        before(resetTestModule);
        after(cleanupTestModule);
        it('should have rebuilt ffi-napi module using clang mode', async () => {
            await rebuild_2.rebuild({
                buildPath: testModulePath,
                electronVersion: testElectronVersion,
                arch: process.arch,
                onlyModules: ['ffi-napi'],
                force: true,
                useElectronClang: true
            });
            await rebuild_1.expectNativeModuleToBeRebuilt(testModulePath, 'ffi-napi');
        });
    });
});
//# sourceMappingURL=rebuild.js.map